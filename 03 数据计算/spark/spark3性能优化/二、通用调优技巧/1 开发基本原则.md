我们先从应用开发的角度入手，去探讨开发阶段应该遵循的基础原则。如果能在开发阶段就打好基础、防患于未然，业务应用的执行性能往往会有个不错的起点。

结合以往的开发经验及spark官网，开发的基本原则可以归纳为三类:
- 坐享其成，利用spark自身配置参数。
- 能省则省、能拖则拖，降低数据计算量，延迟shuffle操作。
- 跳出单机思维，面向对象编程。

## 1、坐享其成，利用spark自身配置参数。
通过设置相关的spark配置项，或是调用相应的 API 去充分享用 Spark 自身带来的性能优势。
- 钨丝计划Tungsten
  - 二进制数据结构
  - Java Unsafe API 管理堆外内存
  - 全阶段代码生成
- AQE（Adaptive Query Execution）全称“自适应查询执行”。
  - join策略调整
  - 数据倾斜自动调整
  - 自动分区合并
  - 动态分区剪裁
- 使用 Parquet、ORC 等文件格式，去坐享谓词下推带来的数据读取效率。

## 2、能省则省、能拖则拖，降低数据计算量，延迟或减少shuffle操作。
- 降低数据计算量
    - 避免创建重复的RDD
    - 尽可能复用同一个RDD
    - 对多次使用的RDD进行持久化（cache、persist）
    - 使用Kryo优化序列化性能
    - 优化数据结构
        
        Java中，有三种类型比较耗费内存：
        
        - 对象，每个Java对象都有对象头、引用等额外的信息，因此比较占用内存空间。
        
        - 字符串，每个字符串内部都有一个字符数组以及长度等额外信息。
        
        - 集合类型，比如HashMap、LinkedList等，因为集合类型内部通常会使用一些内部类来封装集合元素，比如Map.Entry。
        
        因此Spark官方建议，在Spark编码实现中，特别是对于算子函数中的代码，尽量不要使用上述三种数据结构，尽量使用字符串替代对象，使用原始类型（比如Int、Long）替代字符串，使用数组替代集合类型，这样尽可能地减少内存占用，从而降低GC频率，提升性能。在可能以及合适的情况下，使用占用内存较少的数据结构，但是前提是要保证代码的可维护性。
    - 对数据进行压缩
    - 尽可能的数据本地化
    - 广播大变量

        有时在开发过程中，会遇到需要在算子函数中使用外部变量的场景（尤其是大变量，比如100M以上的大集合），那么此时就应该使用Spark的广播（Broadcast）功能来提升性能。
        
        在算子函数中使用到外部变量时，默认情况下，Spark会将该变量复制多个副本，通过网络传输到task中，此时每个task都有一个变量副本。如果变量本身比较大的话（比如100M，甚至1G），那么大量的变量副本在网络中传输的性能开销，以及在各个节点的Executor中占用过多内存导致的频繁GC，都会极大地影响性能。
        
        因此对于上述情况，如果使用的外部变量比较大，建议使用Spark的广播功能，对该变量进行广播。广播后的变量，会保证每个Executor的内存中，只驻留一份变量副本，而Executor中的task执行时共享该Executor中的那份变量副本。这样的话，可以大大减少变量副本的数量，从而减少网络传输的性能开销，并减少对Executor内存的占用开销，降低GC的频率。
- 延迟或减少shuffle操作
    - 尽量避免使用shuffle类算子
    
        - 使用广播变量来模拟使用join，使用情况：一个RDD比较大，一个RDD比较小（几百M或一两G）。
        - join算子=广播变量+filter、广播变量+map、广播变量+flatMap
    - 使用map-side预聚合的shuffle操作
    
        map-side预聚合，说的是在每个节点本地对相同的key进行一次聚合操作，类似于MapReduce中的本地combiner。
        
        map-side预聚合之后，每个节点本地就只会有一条相同的key，因为多条相同的key都被聚合起来了。其它节点在拉取所有节点上的相同key时，就会大大减少需要拉取的数据数量，从而也就减少了磁盘IO以及网络传输开销。
        
    - 使用高性能的算子
        
        - 使用reduceByKey/aggregateByKey替代groupByKey
        - mapPartitions替代map
        - foreachPartitions代替foreach
        - filter之后进行coalesce操作
        - repartitionAndSortWithinPartitions替代repartition与sort类操作。
        
            因为该算子可以一边进行重分区的shuffle操作，一边进行排序。shuffle与sort两个操作同时进行，比先shuffle再sort来说，性能可能是要高的。

## 3、跳出单机思维，面向对象编程。

